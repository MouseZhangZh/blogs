---
layout: post
title: "QtDbus简介"
excerpt: "QtDBus是一个使用D-Bus协议进行进程间通信的仅在Unix运行的库，是对D-Bus底层API的封装实现。"
categories: [Qt, Dbus]
comments: true
---

参考资料列表：

[dbus参考资料1](https://www.cnblogs.com/chendeqiang/p/12861670.html)

[dbus参考资料2](https://www.cnblogs.com/klb561/p/9135642.html)

[dbus参考资料3](https://blog.51cto.com/9291927/2118184)

[dbus参考资料4](https://blog.csdn.net/shawzg/article/details/112425307)

[dbus参考资料5](https://www.cnblogs.com/klb561/p/9058282.html)

[dbus参考资料6](https://blog.51cto.com/9291927/2118468)

[dbus参考资料7](https://doc.qt.io/archives/qt-4.8/qtdbus-module.html)

[dbus参考资料8](http://www.fanjiafei.cn/2018/02/10/d-bus_qdbus/)

[dbus参考资料9](https://segmentfault.com/a/1190000011361916)

[dbus参考资料10](https://dbus.freedesktop.org/doc/dbus-tutorial.html)

[dbus参考资料11](https://blog.csdn.net/flowingflying/article/details/4527634)

[dbus参考资料12](http://blog.chinaunix.net/uid-29043620-id-5761099.html)

[dbus参考资料13](https://www.cnblogs.com/skogkatt/archive/2015/01/17/4231225.html)

[Dbus源码](https://dbus.freedesktop.org/releases/dbus/)

[Dbus官网](https://www.freedesktop.org/wiki/Software/dbus/)

[IPC参考资料1](https://www.cnblogs.com/lnlvinso/p/10872512.html)

[管道参考资料1](https://blog.csdn.net/X_Perseverance/article/details/99179114)

[管道及有名管道](http://www.ibm.com/developerworks/cn/linux/l-ipc/part1/)

[信号·上](http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html)

[信号·下](http://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html)

[消息队列](http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/)

[信号量](http://www.ibm.com/developerworks/cn/linux/l-ipc/part4/)

[共享内存·上](http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html)

[共享内存·下](http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)

[socket](http://www.ibm.com/developerworks/cn/linux/l-ipc/)


# IPC

## 概述

> 进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。这使得一个程序能够在同一时间里处理许多用户的要求。因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话。IPC接口就提供了这种可能性。每个IPC方法均有它自己的优点和局限性，一般，对于单个程序而言使用所有的IPC方法是不常见的。

## 分类

IPC方法包括管道（PIPE）、消息队列、信号量、共享内存以及套接字（Socket）。

1. 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

2. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；

3. 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

5. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

6. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

# 管道

## 相关概念

管道是Linux支持的最初Unix IPC形式之一，具有以下特点：

管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；

只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；

单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

## 匿名管道

### 简介

匿名管道正因为提供的功能很单一，所以它所需要的系统的开销也就比命名管道小很多，在本地机器上可以使用匿名管道来实现父进程和子进程之间的通信，这里需要注意两点，第一就是在本地机器上，这是因为匿名管道不支持跨网络之间的两个进程之间的通信，第二就是实现的是父进程和子进程之间的通信，而不是任意的两个进程。然后得话还顺便介绍匿名管道的另外一种功能，其通过匿名管道可以实现子进程输出的重定向。

### 用法

#### 创建

```C++
#include <unistd.h>
int pipe(int fd[2])
```

该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在亲缘关系，这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。

#### 读写规则

管道两端可分别用描述字`fd[0]`以及`fd[1]`来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字`fd[0]`表示，称其为管道读端；另一端则只能用于写，由描述字`fd[1]`来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的I/O函数都可以用于管道，如close、read、write等等。

从管道中读取数据：

如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为0；

当管道的写端存在时，如果请求的字节数目大于`PIPE_BUF`，则返回管道中现有的数据字节数，如果请求的字节数目不大于`PIPE_BUF`，则返回管道中现有数据字节数（此时，管道中数据量小于请求的数据量）；或者返回请求的字节数（此时，管道中数据量不小于请求的数据量）。注：（PIPE_BUF在include/linux/limits.h中定义，不同的内核版本可能会有所不同）。

验证Demo:

```C++
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int pipe_fd[2];
    pid_t pid;
    char r_buf[100];
    char w_buf[4];
    char* p_wbuf;
    int r_num;
    int cmd;

    memset(r_buf,0,sizeof(r_buf));
    memset(w_buf,0,sizeof(r_buf));
    p_wbuf=w_buf;
    if(pipe(pipe_fd)<0)
    {
        printf("pipe create error\n");
        return -1;
    }

    if((pid=fork())==0)
    {
        printf("\n");
        close(pipe_fd[1]);
        sleep(3);//确保父进程关闭写端
        r_num=read(pipe_fd[0],r_buf,100);
        printf( "read num is %d   the data read from the pipe is %d\n",r_num,atoi(r_buf));

        close(pipe_fd[0]);
        exit(0);
    }
    else if(pid>0)
    {
        close(pipe_fd[0]);//read
        strcpy(w_buf,"111");
        if(write(pipe_fd[1],w_buf,4)!=-1)
            printf("parent write over\n");
        close(pipe_fd[1]);//write
        printf("parent close fd[1] over\n");
        sleep(10);
    }
    return 0;
}
```
输出结果:
```
/home/zhangzihao/CLionProjects/Demos/cmake-build-debug/Demos
parent write over
parent close fd[1] over

read num is 4   the data read from the pipe is 111

Process finished with exit code 0
```

向管道中写入数据：

向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。

注：只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的`SIFPIPE`信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。

验证Demo:

```C++
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int pipe_fd[2];
    pid_t pid;
    char r_buf[4];
    char* w_buf;
    int writenum;
    int cmd;

    memset(r_buf,0,sizeof(r_buf));
    if(pipe(pipe_fd)<0)
    {
        printf("pipe create error\n");
        return -1;
    }

    if((pid=fork())==0)
    {
        close(pipe_fd[0]);
        close(pipe_fd[1]);
        sleep(10);
        exit(0);
    }
    else if(pid>0)
    {
        sleep(1);  //等待子进程完成关闭读端的操作
        close(pipe_fd[0]);//write
        w_buf="111";
        if((writenum=write(pipe_fd[1],w_buf,4))==-1)
            printf("write to pipe error\n");
        else
            printf("the bytes write to pipe is %d \n", writenum);

        close(pipe_fd[1]);
    }
    return 0;
}
```

输出结果:
```
/home/zhangzihao/CLionProjects/Demos/cmake-build-debug/Demos

Process finished with exit code 141 (interrupted by signal 13: SIGPIPE)
```

 Broken pipe的原因就是该管道以及它的所有fork()产物的读端都已经被关闭。如果在父进程中保留读端，即在写完pipe后，再关闭父进程的读端，也会正常写入pipe，可自行验证一下该结论。因此，在向管道写入数据时，至少应该存在某一个进程，其中管道读端没有被关闭，否则就会出现上述错误（管道断裂,进程收到了SIGPIPE信号，默认动作是进程终止）。

#### PIPE_BUF与原子性问题

> Need to be done!!!

4种情况：
1. n <= PIPE_BUF，O_NONBLOCK disable
2. n <= PIPE_BUF，O_NONBLOCK enable
3. n > PIPE_BUF，O_NONBLOCK disable
4. n > PIPE_BUF，O_NONBLOCK enable

#### 局限性

* 只支持单向数据流；

* 只能用于具有亲缘关系的进程之间；

* 没有名字；

* 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
    >  A pipe has a limited capacity. If the pipe is full, then a write(2) will block or fail, depending on whether the O_NONBLOCK flag is set (see below). Different implementations have different limits for the pipe capacity. Applications should not rely on a particular capacity: an application should be designed so that a reading process consumes data as soon as it is available, so that a writing process does not remain blocked.
    In Linux versions before 2.6.11, the capacity of a pipe was the same as the system page size (e.g., 4096 bytes on i386). Since Linux 2.6.11, the pipe capacity is 65536 bytes.

    管道的容量是有限的，在 2.6.11 之前的 Linux 版本中，管道的容量与系统页面大小相同，但自 Linux 2.6.11 以来，管道容量为 65536 字节。

* 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；

## 流管道

与linux中文件操作有文件流的标准I/O一样，管道的操作也支持基于文件流的模式。接口函数如下：

库函数：popen();

原型：FILE *open (char *command,char *type);

返回值：如果成功，返回一个新的文件流。如果无法创建进程或者管道，返回NULL。管道中数据流的方向是由第二个参数type控制的。此参数可以是r或者w，分别代表读或写。但不能同时为读和写。在Linux 系统下，管道将会以参数type中第一个字符代表的方式打开。所以，如果你在参数type中写入rw，管道将会以读的方式打开。

使用popen()创建的管道必须使用pclose()关闭。其实，popen/pclose和标准文件输入/输出流中的fopen()/fclose()十分相似。

库函数：pclose();

原型：int pclose(FILE *stream);

返回值：返回系统调用wait4()的状态。

如果stream无效，或者系统调用wait4()失败，则返回-1。注意此库函数等待管道进程运行结束，然后关闭文件流。库函数pclose()在使用popen（）创建的进程上执行wait4()函数，它将破坏管道和文件系统。

## 命名管道

### 简介

管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间通信，在有名管道（named pipe或FIFO）提出后，该限制得到了克服。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。

### 用法

#### 创建

```C++
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char * pathname, mode_t mode)
```

该函数的第一个参数是一个普通的路径名，也就是创建后FIFO的名字。第二个参数与打开普通文件的open()函数中的mode 参数相同。 如果mkfifo的第一个参数是一个已经存在的路径名时，会返回EEXIST错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开FIFO的函数就可以了。一般文件的I/O函数都可以用于FIFO，如close、read、write等等。

#### 读写规则

有名管道比管道多了一个打开操作：open。

FIFO的打开规则：

如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。

如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。

验证Demo(验证写打开对读打开的依赖性):

```C++
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#define FIFO_SERVER "/tmp/fifoserver"
int handle_client(char*);

int w_open(char*arg)
//0  open error for no reading
//-1 open error for other reasons
//1  open ok
{
    if(open(arg,O_WRONLY|O_NONBLOCK,0)==-1)
    {   if(errno==ENXIO)
        {
            return 0;
        }
        else
            return -1;
    }
    return 1;

}

int main(int argc,char** argv)
{
    int r_rd;
    int w_fd;
    pid_t pid;
    if((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)<0)&&(errno!=EEXIST))
        printf("cannot create fifoserver\n");
    handle_client(FIFO_SERVER);

}
int handle_client(char* arg)
{
    int ret;
    ret=w_open(arg);
    switch(ret)
    {
        case 0:
        {
            printf("open %s error\n",arg);
            printf("no process has the fifo open for reading\n");
            return -1;
        }
        case -1:
        {
            printf("something wrong with open the fifo except for ENXIO");
            return -1;
        }
        case 1:
        {
            printf("open server ok\n");
            return 1;
        }
        default:
        {
            printf("w_no_r return ----\n");
            return 0;
        }
    }
    unlink(FIFO_SERVER);
}
```

输出结果:

```
/home/zhangzihao/CLionProjects/Demos/cmake-build-debug/Demos
open /tmp/fifoserver error
no process has the fifo open for reading

Process finished with exit code 0
```

FIFO的读写规则:

从FIFO中读取数据：

约定：如果一个进程为了从FIFO中读取数据而阻塞打开FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。

如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。

对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：当前FIFO内有数据，但有其它进程在读这些数据；另外就是FIFO内没有数据。解阻塞的原因则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求多少数据量。

读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。

如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。

注：如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。

向FIFO中写入数据：

约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。

对于设置了阻塞标志的写操作：

当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。

当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。

对于没有设置阻塞标志的写操作：

当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。

当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；

对FIFO读写规则的验证：

下面提供了两个对FIFO的读写程序，适当调节程序中的很少地方或者程序的命令行参数就可以对各种FIFO读写规则进行验证。

***
**注意:以下两个程序应该已经不适用与现在的Linux版本，size大小已经不是页面大小**
***

```C++
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#define FIFO_SERVER "/tmp/fifoserver"
main(int argc,char** argv)
//参数为即将写入的字节数
{
    int fd;
    char w_buf[4096*2];
    int real_wnum;
    memset(w_buf,0,4096*2);
    if((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)<0)&&(errno!=EEXIST))
        printf("cannot create fifoserver\n");
    if(fd==-1)
        if(errno==ENXIO)
            printf("open error; no reading process\n");
         
        fd=open(FIFO_SERVER,O_WRONLY|O_NONBLOCK,0);
    //设置非阻塞标志
    //fd=open(FIFO_SERVER,O_WRONLY,0);
    //设置阻塞标志
    real_wnum=write(fd,w_buf,2048);
    if(real_wnum==-1)
    {
        if(errno==EAGAIN)
            printf("write to fifo error; try later\n");
    }
    else 
        printf("real write num is %d\n",real_wnum);
    real_wnum=write(fd,w_buf,5000);
    //5000用于测试写入字节大于4096时的非原子性
    //real_wnum=write(fd,w_buf,4096);
    //4096用于测试写入字节不大于4096时的原子性
     
    if(real_wnum==-1)
        if(errno==EAGAIN)
            printf("try later\n");
}
```

```C++
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#define FIFO_SERVER "/tmp/fifoserver"
main(int argc,char** argv)
{
    char r_buf[4096*2];
    int  fd;
    int  r_size;
    int  ret_size;
    r_size=atoi(argv[1]);
    printf("requred real read bytes %d\n",r_size);
    memset(r_buf,0,sizeof(r_buf));
    fd=open(FIFO_SERVER,O_RDONLY|O_NONBLOCK,0);
    //fd=open(FIFO_SERVER,O_RDONLY,0);
    //在此处可以把读程序编译成两个不同版本：阻塞版本及非阻塞版本
    if(fd==-1)
    {
        printf("open %s for read error\n");
        exit(); 
    }
    while(1)
    {
         
        memset(r_buf,0,sizeof(r_buf));
        ret_size=read(fd,r_buf,r_size);
        if(ret_size==-1)
            if(errno==EAGAIN)
                printf("no data avlaible\n");
        printf("real read bytes %d\n",ret_size);
        sleep(1);
    }   
    pause();
    unlink(FIFO_SERVER);
}
```

程序应用说明：

把读程序编译成两个不同版本：

* 阻塞读版本:br
* 以及非阻塞读版本nbr

把写程序编译成两个四个版本：

* 非阻塞且请求写的字节数大于PIPE_BUF版本：nbwg
* 非阻塞且请求写的字节数不大于PIPE_BUF版本：版本nbw
* 阻塞且请求写的字节数大于PIPE_BUF版本：bwg
* 阻塞且请求写的字节数不大于PIPE_BUF版本：版本bw

下面将使用br、nbr、w代替相应程序中的阻塞读、非阻塞读

验证阻塞写操作：

1. 当请求写入的数据量大于PIPE_BUF时的非原子性：
* nbr 1000
* bwg
2. 当请求写入的数据量不大于PIPE_BUF时的原子性：
* nbr 1000
* bw

验证非阻塞写操作：

1. 当请求写入的数据量大于PIPE_BUF时的非原子性：
* nbr 1000
* nbwg
2. 请求写入的数据量不大于PIPE_BUF时的原子性：
* nbr 1000
* nbw

不管写打开的阻塞标志是否设置，在请求写入的字节数大于4096时，都不保证写入的原子性。但二者有本质区别：

对于阻塞写来说，写操作在写满FIFO的空闲区域后，会一直等待，直到写完所有数据为止，请求写入的数据最终都会写入FIFO；

而非阻塞写则在写满FIFO的空闲区域后，就返回(实际写入的字节数)，所以有些数据最终不能够写入。

对于读操作的验证则比较简单，不再讨论。

# 信号

## 相关概念

### 信号本质

信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。

### 信号来源

信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。

## 信号种类

可以从两个不同的分类角度对信号进行分类：

（1）可靠性方面：可靠信号与不可靠信号；

（2）与时间的关系上：实时信号与非实时信号。

使用命令`kill -l`可查看系统所支持的所有信号。

```
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```

### 可靠信号与不可靠信号

#### 不可靠信号

Linux信号机制基本上是从Unix系统中继承过来的。早期Unix系统中的信号机制比较简单和原始，后来在实践中暴露出一些问题，因此，把那些建立在早期机制上的信号叫做"不可靠信号"，信号值小于SIGRTMIN(Red hat 7.2中，SIGRTMIN=32，SIGRTMAX=63)的信号都是不可靠信号。这就是"不可靠信号"的来源。它的主要问题是：

进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用signal()，重新安装该信号。
信号可能丢失，后面将对此详细阐述。
因此，早期unix下的不可靠信号主要指的是进程可能对信号做出错误的反应以及信号可能丢失。
Linux支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，Linux下的不可靠信号问题主要指的是信号可能丢失。

#### 可靠信号

随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。所以，后来出现的各种Unix版本分别在这方面进行了研究，力图实现"可靠信号"。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。同时，信号的发送和安装也出现了新版本：信号发送函数`sigqueue()`及信号安装函数`sigaction()`。POSIX.4对可靠信号机制做了标准化。但是，POSIX只对可靠信号机制应具有的功能以及信号机制的对外接口做了标准化，对信号机制的实现没有作具体的规定。

信号值位于`SIGRTMIN`和`SIGRTMAX`之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux在支持新版本的信号安装函数`sigation()`以及信号发送函数`sigqueue()`的同时，仍然支持早期的`signal()`信号安装函数，支持信号发送函数`kill()`。

注：不要有这样的误解：由`sigqueue()`发送、sigaction安装的信号就是可靠的。事实上，可靠信号是指后来添加的新信号（信号值位于`SIGRTMIN`及`SIGRTMAX`之间）；不可靠信号是信号值小于`SIGRTMIN`的信号。信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前linux中的`signal()`是通过`sigation()`函数实现的，因此，即使通过`signal()`安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由`signal()`安装的实时信号支持排队，同样不会丢失。

对于目前linux的两个信号安装函数:`signal()`及`sigaction()`来说，它们都不能把`SIGRTMIN`以前的信号变成可靠信号（都不支持排队，仍有可能丢失，仍然是不可靠信号），而且对`SIGRTMIN`以后的信号都支持排队。这两个函数的最大区别在于，经过sigaction安装的信号都能传递信息给信号处理函数（对所有信号这一点都成立），而经过`signal`安装的信号却不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。

2、实时信号与非实时信号
早期Unix系统只定义了32种信号，Ret hat7.2支持64种信号，编号0-63(SIGRTMIN=31，SIGRTMAX=63)，将来可能进一步增加，这需要得到内核的支持。前32种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的CTRL ^C时，会产生SIGINT信号，对该信号的默认反应就是进程终止。后32个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。实时信号是POSIX标准的一部分，可用于应用进程。

非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。

## 进程对信号的响应

进程可以通过三种方式来响应一个信号：

1. 忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：`SIGKILL`及`SIGSTOP`；

2. 捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数；

3. 执行缺省操作，Linux对每种信号都规定了默认操作，详细情况请参考其它资料。注意，进程对实时信号的缺省反应是进程终止。

Linux究竟采用上述三种方式的哪一个来响应信号，取决于传递给相应API函数的参数。

## 信号的发送

发送信号的主要函数有：`kill()`、`raise()`、 `sigqueue()`、`alarm()`、`setitimer()`以及`abort()`。

1. kill()

```C++
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid,int signo)
```

|参数pid的值|信号的接受进程|
|:---:|:---:|
|pid > 0|进程ID为pid的进程|
|pid = 0|同一个进程组的进程|
|pid < 0 && pid!=-1|进程组ID为 -pid的所有进程|
|pid = -1|除发送进程自身外，所有进程ID大于1的进程|
|||

Sinno是信号值，当为0时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在，以及当前进程是否具有向目标发送信号的权限（root权限的进程可以向任何进程发送信号，非root权限的进程只能向属于同一个session或者同一个用户的进程发送信号）。

Kill()最常用于pid>0时的信号发送，调用成功返回 0； 否则，返回 -1。 注：对于pid<0时的情况，对于哪些进程将接受信号，各种版本说法不一，其实很简单，参阅内核源码kernal/signal.c即可，上表中的规则是参考red hat 7.2。

2. raise()

```C++
#include <signal.h>
int raise(int signo)
```

向进程本身发送信号，参数为即将发送的信号值。调用成功返回 0；否则，返回 -1。

3. sigqueue()

```C++
#include <sys/types.h>
#include <signal.h>
int sigqueue(pid_t pid, int sig, const union sigval val)
```

调用成功返回 0；否则，返回 -1。

`sigqueue()`是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数`sigaction()`配合使用。

`sigqueue`的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构`union sigval`，指定了信号传递的参数，即通常所说的4字节值。

```C++
typedef union sigval {
    int  sival_int;
    void *sival_ptr;
}sigval_t;
```

sigqueue()比kill()传递了更多的附加信息，但sigqueue()只能向一个进程发送信号，而不能发送信号给一个进程组。如果signo=0，将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。

在调用sigqueue时，sigval_t指定的信息会拷贝到3参数信号处理函数（3参数信号处理函数指的是信号处理函数由sigaction安装，并设定了sa_sigaction指针，稍后将阐述）的siginfo_t结构中，这样信号处理函数就可以处理这些信息了。由于sigqueue系统调用支持发送带参数信号，所以比kill()系统调用的功能要灵活和强大得多。

注：sigqueue（）发送非实时信号时，第三个参数包含的信息仍然能够传递给信号处理函数； 
sigqueue（）发送非实时信号时，仍然不支持排队，即在信号处理函数执行过程中到来的所有相同信号，都被合并为一个信号。


4. alarm()

5. setitimer()

6. abort()

# 消息队列

# 信号量

# 共享内存

# socket

# QtDbus 简介

QtDBus是一个使用D-Bus协议进行进程间通信的仅在Unix运行的库，是对D-Bus底层API的封装实现。
QtDBus模块提供了使用Qt信号槽机制扩展的接口。要使用QtDBus模块，需要在代码中加入以下代码：

```C++
#include <QtDBus>
```

如果使用qmake构建程序，需要在工程文件中增加下列代码来链接QtDBus库：

```
QT += qdbus
```

# QtDBus类型系统

## QtDBus类型系统简介

D-Bus有一种基于几种原生与在数组和结构中的原生类型组成的复合类型的扩展类型系统。QtDBus模块通过QDBusArgument类实现了类型系统，允许用户通过总线发送和接收每一种C++类型。

| Qt类型 | D-Bus类型 |
| :---: | :---: |
| uchar | BYTE |
| bool | BOOLEAN |
| short	| INT16 |
| ushort | UINT16 |
| int | INT32 |
| uint | UINT32 |
| qlonglong	| INT64 |
| qulonglong | UINT64 |
| double | DOUBLE |
| QString | STRING |
| QDBusVariant | VARIANT |
| QDBusObjectPath | OBJECT_PATH |
| QDBusSignature | SIGNATURE |

除了原生类型，QDBusArgument也支持在Qt应用中广泛使用的两种非原生类型，QStringList和QByteArray。

## 复合类型
D-Bus指定由原生类型聚合而成的三种复合类型：ARRAY、STRUCT和 maps/dictionaries。ARRAY零个或多个相同元素的集合，STRUCT是由不同类型的固定数量的元素组成的集合，Maps or dictionaries是元素对的数组，一个map中可以有零个或多个元素。

## 扩展类型系统
为了在QtDBus模块使用自定义类型，自定义类型必须使用Q_DECLARE_METATYPE()声明为Qt元类型，使用qDBusRegisterMetaType()函数注册。流操作符会被注册系统自动找到。
QtDBus模块为Qt容器类使用数组和map提供了模板特化，例如QMap和QList，不必实现流操作符函数。对于其它的类型，流操作符必须显示实现。

## 类型系统使用
QtDBus定义的所有类型能用于通过总线发送和接收消息。不能使用上述类型之外的任何类型，包括typedefs定义的列表类型，如
QList和QMap< QString,QVariant>

# QtDBus常用类
## QDBusMessage
QDBusMessage类表示D-Bus总线发送或接收的一个消息。
QDBusMessage对象代表总线上四种消息类型中的一种，四种消息类型如下：

* Method calls
* Method return values
* Signal emissions
* Error codes

可以使用静态函数createError()、createMethodCall()、createSignal()创建消息。使用QDBusConnection::send() 函数发送消息。

## QDBusConnection
QDBusConnection代表到D-Bus总线的一个连接，是一个D-Bus会话的起始点。通过QDBusConnection连接对象，可以访问远程对象、接口，连接远程信号到本地槽函数，注册对象等。

D-Bus连接通过connectToBus()函数创建，connectToBus()函数会创建一个到总线服务端的连接，完成初始化工作，并关联一个连接名到连接。

使用disconnectFromBus()函数会断开连接。一旦断开连接后，调用connectToBus()函数将不会重建连接，必须创建新的QDBusConnection实例。

作为两种最常用总线类型的辅助，sessionBus()和systemBus()函数分别创建到会话在总线和系统总线的连接并返回，会在初次使用时打开，在QCoreApplication析构函数调用时断开。

D-Bus支持点对点通信，不必使用总线服务。两个应用程序可以直接交流和交换消息。可以通过传递一个地址到connectToBus()函数实现。

打开一个type类型的连接，并关联name连接名，返回关联本连接的QDBusConnection对象。

```C++
QDBusConnection connectToBus(BusType type, const QString & name)
```
***
打开一个地址为address的私有总线，并关联name连接名，返回关联本连接的QDBusConnection对象。
```C++
QDBusConnection connectToBus(const QString & address, const QString & name)
```
***
打开一个点对点的连接到address地址，并关联name连接名，返回关联本连接的QDBusConnection对象。

```C++
QDBusConnection connectToPeer(const QString & address, const QString & name)
```
***
关闭名为name的总线连接

```C++
void disconnectFromBus(const QString & name)
```
***
关闭名为name的对等连接

```C++
void disconnectFromPeer(const QString & name)
```
***
返回一个D-Bus总线系统知道的本机ID

```C++
QByteArray localMachineId()
```
***
返回发送信号的连接

```C++
QDBusConnection sender()
```
***
返回一个打开到session总线的QDBusConnection对象

```C++
QDBusConnection sessionBus()
```
***
返回一个打开到system总线的QDBusConnection对象

```C++
QDBusConnection systemBus()
```
***
发送message消息到连接，并立即返回。本函数只支持method调用。返回一个用于追踪应答的QDBusPendingCall对象。

```C++
QDBusPendingCall asyncCall(const QDBusMessage & message, int timeout = -1)const
```
***
通过本连接发送消息message，并且阻塞，等待应答。

```C++
QDBusMessage call(const QDBusMessage & message, QDBus::CallMode mode = QDBus::Block, int timeout = -1 ) const
```
***
注册object对象到路径path，options选项指定由多少对象会被暴露到D-Bus总线，如果注册成功，返回true。

```C++
bool registerObject(const QString & path, QObject * object, RegisterOptions options = ExportAdaptors)
```
***
试图在D-Bus总线上注册serviceName服务，如果注册成功，返回true；如果名字已经在其它应用被注册，则注册失败。

```C++
bool registerService(const QString & serviceName)
```

## QDBusInterface

QDBusInterface是远程对象接口的代理。

QDBusInterface是一种通用的访问器类，用于调用远程对象，连接到远程对象导出的信号，获取/设置远程属性的值。当没有生成表示远程接口的生成代码时时，QDBusInterface类对远程对象的动态访问非常有用。

调用通常是通过使用call（）函数来实现，call函数构造消息，通过总线发送消息，等待应答并解码应答。信号使用QObject::connect()函数进行连接。最终，使用QObject::property()和QObject::setProperty()函数对属性进行访问。

## QDBusReply

QDBusReply类用于存储对远程对象的方法调用的应答。

一个QDBusReply对象是方法调用的应答QDBusMessage对象的一个子集。QDBusReply对象只包含第一个输出参数或错误代码，并由QDBusInterface派生类使用，以允许将错误代码返回为函数的返回参数。

```C++
QDBusReply<QString> reply = interface->call("RemoteMethod");
 if (reply.isValid())
     // use the returned value
     useValue(reply.value());
 else
     // call failed. Show an error condition.
     showError(reply.error());
```

对于没有输出参数或返回值的远程调用，使用isValid()函数测试应答是否成功。

## QDBusAbstractAdaptor

QDBusAbstractAdaptor类使用D-Bus Adaptor基类。

QDBusAbstractAdaptor类是用于使用D-Bus向外部提供接口的所有对象的起点。可以通过将一个或多个派生自QDBusAbstractAdaptor的类附加到一个普通QObject对象上，使用QDBusConnection::registerObject注册QObject对象可以实现。QDBusAbstractAdaptor是一个轻量级封装，主要用于中继调用实际对象及其信号。

每个QDBusAbstractAdaptor派生类都应该使用类定义中的Q_CLASSINFO宏来定义D-Bus接口。注意，这种方式只有一个接口可以暴露。

QDBusAbstractAdaptor使用了信号、槽、属性的标准QObject机制来决定哪些信号、槽、属性被暴露到总线。任何QDBusAbstractAdaptor派生类发送的信号通过任何D-Bus连接自动中继到注册的对象上。

QDBusAbstractAdaptor派生类对象必须使用new创建在堆上，不必由用户删除。

## QDBusAbstractInterface

QDBusAbstractInterface是QtDBus模块中允许访问远程接口的所有D-Bus接口的基类。

自动生成的代码类也继承自QDBusAbstractInterface，此描述的所有方法在生成的代码中也有效。除了此处的描述，生成代码类为远程方法提供了成员函数，允许在编译时检查正确参数和返回值，以及匹配的属性类型和匹配的信号参数。

```C++
QDBusPendingCall asyncCall(const QString & method, 
                           const QVariant & arg1 = QVariant(), 
                           const QVariant & arg2 = QVariant(), 
                           const QVariant & arg3 = QVariant(), 
                           const QVariant & arg4 = QVariant(),
                           const QVariant & arg5 = QVariant(), 
                           const QVariant & arg6 = QVariant(), 
                           const QVariant & arg7 = QVariant(), 
                           const QVariant & arg8 = QVariant())
```

调用本接口中的method方法，传递参数到远程的method。

要调用的参数会通过D-Bus输入参数传递到远程方法，返回的QDBusPendingCall对象用于定义应答信息。
本函数最多有8个参数，如果参数多于8个，或是传递可变数量的参数，使用asyncCallWithArgumentList()函数。

```C++
QString value = retrieveValue();
QDBusPendingCall pcall = interface->asyncCall(QLatin1String("Process"), value);

QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);

QObject::connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)),
                 this, SLOT(callFinishedSlot(QDBusPendingCallWatcher*)));
```

## QDBusArgument

QDBusArgument类用于整理和分发D-Bus参数。QDBusArgument用于通过D-Bus发送参数到远程应用，并接收返回。

QDBusArgument是QtDBus类型系统的核心类，QtDBus类型系统用于解析和原生类型。复合类型可以通过在数组、词典或结构中使用一个或多个原生类型创建。

下列代码展示了使用QtDBus类型系统构造的包含一个整数和字符串的结构。

```C++
struct MyStructure
 {
     int count;
     QString name;
 };
 Q_DECLARE_METATYPE(MyStructure)
// Marshall the MyStructure data into a D-Bus argument
QDBusArgument &operator<<(QDBusArgument &argument, const MyStructure &mystruct)
{
    argument.beginStructure();
    argument << mystruct.count << mystruct.name;
    argument.endStructure();
    return argument;
}

// Retrieve the MyStructure data from the D-Bus argument
const QDBusArgument &operator>>(const QDBusArgument &argument, MyStructure &mystruct)
{
    argument.beginStructure();
    argument >> mystruct.count >> mystruct.name;
    argument.endStructure();
    return argument;
}
```

在QDBusArgument使用这个结构前，必须使用qDBusRegisterMetaType()函数进行注册。因此，在程序中应该则增加如下代码：
qDBusRegisterMetaType<MyStructure>();
一旦注册，类型可以在呼出方法调用（QDBusAbstractInterface::call()）、来自注册对象的信号发射或来自远程应用的传入调用。

## QDBusConnectionInterface

QDBusConnectionInterface类提供了对D-Bus总线服务的访问。

D-Bus总线服务端中提供了一个特殊的接口org.freedesktop.DBus，允许客户端运行访问总线的某些属性，例如当前连接的客户端列表，QDBusConnectionInterface类提供对org.freedesktop.DBus接口的访问。

本类中最常用的是使用registerService()和unregisterService()在总线上注册和注销服务名。

QDBusConnectionInterface类定义四个信号，在总线上有服务状态变化时发送。

```C++
void callWithCallbackFailed(const QDBusError & error, const QDBusMessage & call)
void serviceOwnerChanged(const QString & name, const QString & oldOwner, const QString & newOwner)
void serviceRegistered(const QString & serviceName)
void serviceUnregistered(const QString & serviceName)
```

## QDBusVariant

QDBusVariant类使程序员能够识别由D-Bus类型系统提供的Variant类型。一个使用整数、D-Bus变体类型和字符串作为参数的D-Bus函数可以使用如下的参数列表调用。

```C++
QList<QVariant> arguments;
arguments << QVariant(42) << QVariant::fromValue(QDBusVariant(43)) << QVariant("hello");
myDBusMessage.setArguments(arguments);
```

当D-Bus函数返回一个D-Bus变体类型时，可以使用如下方法获取：

```C++
// call a D-Bus function that returns a D-Bus variant
QVariant v = callMyDBusFunction();
// retrieve the D-Bus variant
QDBusVariant dbusVariant = qvariant_cast<QDBusVariant>(v);
// retrieve the actual value stored in the D-Bus variant
QVariant result = dbusVariant.variant();
```

QDBusVariant中的QVariant需要区分一个正常的D-Bus值和一个QDBusVariant中的值。

# QtDBus工具

## qdbusviewer

qdbusviewer用于查看D-Bus总线上的服务、对象、接口以及接口的method。使用方法直接在命令行执行：`qdbusviewer`

## qdbuscpp2xml

qdbuscpp2xml会解析QObject派生类的C++头文件或是源文件，生成D-Bus的内省xml文件。qdbuscpp2xml 会区分函数的输入输出，如果参数声明为const则会是输入，否则可能会被当作输出。

qdbuscpp2xml使用语法如下：

> qdbuscpp2xml [options...] [files...]

Options参数如下：

-p|-s|-m：只解析脚本化的属性、信号、方法（槽函数）

-P|-S|-M：解析所有的属性、信号、方法（槽函数）

-a：输出所有的脚本化内容，等价于-psm

-A：输出所有的内容，等价于-PSM

-o filename：输出内容到filename文件

解析所有的方法输出到com.scorpio.test.xml文件命令如下：

> qdbuscpp2xml -M test.h -o com.scorpio.test.xml

```C++
<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
  <interface name="com.scorpio.test.value">
    <method name="maxValue">
      <arg type="i" direction="out"/>
    </method>
    <method name="minValue">
      <arg type="i" direction="out"/>
    </method>
    <method name="value">
      <arg type="i" direction="out"/>
    </method>
    <method name="setValue">
      <arg name="value" type="i" direction="in"/>
    </method>
  </interface>
</node>
```

## qdbusxml2cpp

qdbusxml2cpp根据输入文件中定义的接口，生成C++实现代码。

qdbusxml2cpp可以辅助自动生成继承于QDBusAbstractAdaptor和QDBusAbstractInterface两个类的实现代码，用于进程通信服务端和客户端，简化了开发者的代码设计。

qdbusxml2cpp使用语法如下：

> qdbusxml2cpp [options...] [xml-or-xml-file] [interfaces...]

Options参数如下：

-a filename：输出Adaptor代码到filename

-c classname：使用classname作为生成类的类名

-i filename：增加#include到输出

-l classname：当生成Adaptor代码时，使用classname作为父类

-m：在cpp文件中包含 #include "filename.moc"语句

-N：不使用名称空间

-p filename：生成Proxy代码到filename文件

解析com.scorpio.test.xml文件，生成Adaptor类ValueAdaptor，文件名称为valueAdaptor.h、valueAdaptor.cpp命令行如下：

> qdbusxml2cpp com.scorpio.test.xml -i test.h -a valueAdaptor

解析com.scorpio.test.xml文件，生成Proxy类ComScorpioTestValueInterface，文件名称为testInterface.h、testInterface.cpp命令行如下：

> qdbusxml2cpp com.scorpio.test.xml -p testInterface

# QtDBus编程

## 创建服务并注册对象

`test.h`

```C++
#ifndef TEST_H
#define TEST_H
#include <QObject>

class test: public QObject
{
    Q_OBJECT
    //定义Interface名称为com.scorpio.test.value
    Q_CLASSINFO("D-Bus Interface", "com.scorpio.test.value")
public:
    test(int value);

public slots:
    int maxValue();
    int minValue();
    int value();
private:
    int m_value;
};

#endif // TEST_H
```

`test.cpp`

```C++
#include "test.h"

test::test(int value)
{
    m_value = value;
}

int test::maxValue()
{
    return 100;
}
int test::minValue()
{
    return 0;
}
int test::value()
{
    return m_value;
}
```

`main.cpp`

```C++
#include <QCoreApplication>
#include <QDBusConnection>
#include <QDebug>
#include <QDBusError>
#include "test.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    //建立到session bus的连接
    QDBusConnection connection = QDBusConnection::sessionBus();
    //在session bus上注册名为com.scorpio.test的服务
    if(!connection.registerService("com.scorpio.test"))
    {
        qDebug() << "error:" << connection.lastError().message();
        exit(-1);
    }
    test object(60);
    //注册名为/test/objects的对象，把类Object所有槽函数导出为object的method
    connection.registerObject("/test/objects", &object,QDBusConnection::ExportAllSlots);

    return a.exec();
}
```

启动程序后，在命令行打开`qdbusviewer`，查看`session bus`。

双击Method方法会调用该方法。

## 通过QDBusMessage访问Service

确保com.scorpio.test服务运行在总线上。

编写一个控制台程序，使用消息访问com.scorpio.test服务。

```C++
#include <QCoreApplication>
#include <QDBusMessage>
#include <QDBusConnection>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    //构造一个method_call消息，服务名称为：com.scorpio.test，对象路径为：/test/objects
    //接口名称为com.scorpio.test.value，method名称为value
    QDBusMessage message = QDBusMessage::createMethodCall("com.scorpio.test",
                           "/test/objects",
                           "com.scorpio.test.value",
                           "value");
    //发送消息
    QDBusMessage response = QDBusConnection::sessionBus().call(message);
    //判断method是否被正确返回
    if (response.type() == QDBusMessage::ReplyMessage)
    {
        //从返回参数获取返回值
        int value = response.arguments().takeFirst().toInt();
        qDebug() << QString("value =  %1").arg(value);
    }
    else
    {
        qDebug() << "value method called failed!";
    }

    return a.exec();
}
```

## 通过QDBusInterface 访问Service

编写一个控制台程序，使用接口访问com.scorpio.test服务。

```C++
#include <QCoreApplication>
#include <QDBusMessage>
#include <QDBusConnection>
#include <QDBusReply>
#include <QDBusInterface>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    // 创建QDBusInterface接口
    QDBusInterface interface("com.scorpio.test", "/test/objects",
                             "com.scorpio.test.value",
                             QDBusConnection::sessionBus());
    if (!interface.isValid())
    {
        qDebug() << qPrintable(QDBusConnection::sessionBus().lastError().message());
        exit(1);
    }
    //调用远程的value方法
    QDBusReply<int> reply = interface.call("value");
    if (reply.isValid())
    {
        int value = reply.value();
        qDebug() << QString("value =  %1").arg(value);
    }
    else
    {
        qDebug() << "value method called failed!";
    }

    return a.exec();
}
```

## 从D-Bus XML自动生成Proxy类

Proxy Object提供了一种更加直观的方式来访问Service，如同调用本地对象的方法一样。
生成Proxy类的流程如下：

### 使用工具qdbuscpp2xml从object.h生成XML文件

> qdbuscpp2xml -M test.h -o com.scorpio.test.xml

```C++
<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
  <interface name="com.scorpio.test.value">
    <method name="maxValue">
      <arg type="i" direction="out"/>
    </method>
    <method name="minValue">
      <arg type="i" direction="out"/>
    </method>
    <method name="value">
      <arg type="i" direction="out"/>
    </method>
  </interface>
</node>
```

### 使用工具qdbusxml2cpp从XML文件生成继承自QDBusInterface的类

> qdbusxml2cpp com.scorpio.test.xml -p valueInterface

生成两个文件：valueInterface.cpp和valueInterface.h

`valueInterface.h`

```C++
/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp com.scorpio.test.xml -p testInterface
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef TESTINTERFACE_H_1526737677
#define TESTINTERFACE_H_1526737677

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

/*
 * Proxy class for interface com.scorpio.test.value
 */
class ComScorpioTestValueInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "com.scorpio.test.value"; }

public:
    ComScorpioTestValueInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~ComScorpioTestValueInterface();

public Q_SLOTS: // METHODS
    inline QDBusPendingReply<int> maxValue()
    {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("maxValue"), argumentList);
    }

    inline QDBusPendingReply<int> minValue()
    {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("minValue"), argumentList);
    }

    inline QDBusPendingReply<int> value()
    {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QLatin1String("value"), argumentList);
    }

Q_SIGNALS: // SIGNALS
};

namespace com {
  namespace scorpio {
    namespace test {
      typedef ::ComScorpioTestValueInterface value;
    }
  }
}
#endif
```

`valueInterface.cpp`

```C++
/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp com.scorpio.test.xml -p testInterface
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * This file may have been hand-edited. Look for HAND-EDIT comments
 * before re-generating it.
 */

#include "testInterface.h"

/*
 * Implementation of interface class ComScorpioTestValueInterface
 */

ComScorpioTestValueInterface::ComScorpioTestValueInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
{
}

ComScorpioTestValueInterface::~ComScorpioTestValueInterface()
{
}
```

调用Proxy类访问Service如下：

```C++
#include <QCoreApplication>
#include <QDBusMessage>
#include <QDBusConnection>
#include <QDBusReply>
#include <QDBusInterface>
#include <QDebug>
#include "testInterface.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    // 初始化自动生成的Proxy类com::scorpio::test::value
    com::scorpio::test::value test("com.scorpio.test",
                                   "/test/objects",
                                   QDBusConnection::sessionBus());
    // 调用value方法
    QDBusPendingReply<int> reply = test.value();
    //qdbusxml2cpp生成的Proxy类是采用异步的方式来传递Message，
    //所以需要调用waitForFinished来等到Message执行完成
    reply.waitForFinished();
    if (reply.isValid())
    {
        int value = reply.value();
        qDebug() << QString("value =  %1").arg(value);
    }
    else
    {
        qDebug() << "value method called failed!";
    }

    return a.exec();
}
```

# 使用Adapter注册Object

可以直接把test类注册为消息总线上的一个Object，但QT4不推荐。QT4推荐使用Adapter来注册Object。
大多数情况下，可能只需要把自定义的类里的方法有选择的发布到消息总线上，使用Adapter可以很方便的实现选择性发布。

生成Adapter类的流程如下：

使用工具 `qdbuscpp2xml`从`test.h`生成`XML`文件

> qdbuscpp2xml -M test.h -o com.scorpio.test.xml

编辑`com.scorpio.test.xml`，选择需要发布的`method`，不需要发布的删除。

使用工具`qdbusxml2cpp`从`XML`文件生成继承自`QDBusInterface`的类

> qdbusxml2cpp com.scorpio.test.xml -i test.h -a valueAdaptor

生成两个文件：`valueAdaptor.cpp`和`valueAdaptor.h`

`valueAdaptor.h`

```C++
/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp com.scorpio.test.xml -i test.h -a valueAdaptor
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * This file may have been hand-edited. Look for HAND-EDIT comments
 * before re-generating it.
 */

#ifndef VALUEADAPTOR_H_1526742670
#define VALUEADAPTOR_H_1526742670

#include <QtCore/QObject>
#include <QtDBus/QtDBus>
#include "test.h"
class QByteArray;
template<class T> class QList;
template<class Key, class Value> class QMap;
class QString;
class QStringList;
class QVariant;

/*
 * Adaptor class for interface com.scorpio.test.value
 */
class ValueAdaptor: public QDBusAbstractAdaptor
{
    Q_OBJECT
    Q_CLASSINFO("D-Bus Interface", "com.scorpio.test.value")
    Q_CLASSINFO("D-Bus Introspection", ""
"  <interface name=\"com.scorpio.test.value\">\n"
"    <method name=\"maxValue\">\n"
"      <arg direction=\"out\" type=\"i\"/>\n"
"    </method>\n"
"    <method name=\"minValue\">\n"
"      <arg direction=\"out\" type=\"i\"/>\n"
"    </method>\n"
"  </interface>\n"
        "")
public:
    ValueAdaptor(QObject *parent);
    virtual ~ValueAdaptor();

public: // PROPERTIES
public Q_SLOTS: // METHODS
    int maxValue();
    int minValue();
Q_SIGNALS: // SIGNALS
};

#endif
```

`valueAdaptor.cpp`

```C++
/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp com.scorpio.test.xml -i test.h -a valueAdaptor
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#include "valueAdaptor.h"
#include <QtCore/QMetaObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>

/*
 * Implementation of adaptor class ValueAdaptor
 */

ValueAdaptor::ValueAdaptor(QObject *parent)
    : QDBusAbstractAdaptor(parent)
{
    // constructor
    setAutoRelaySignals(true);
}

ValueAdaptor::~ValueAdaptor()
{
    // destructor
}

int ValueAdaptor::maxValue()
{
    // handle method call com.scorpio.test.value.maxValue
    int out0;
    QMetaObject::invokeMethod(parent(), "maxValue", Q_RETURN_ARG(int, out0));
    return out0;
}

int ValueAdaptor::minValue()
{
    // handle method call com.scorpio.test.value.minValue
    int out0;
    QMetaObject::invokeMethod(parent(), "minValue", Q_RETURN_ARG(int, out0));
    return out0;
}
```

调用Adaptor类注册Object对象如下：

```C++
#include <QCoreApplication>
#include <QDBusConnection>
#include <QDebug>
#include <QDBusError>
#include "test.h"
#include "valueAdaptor.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    QDBusConnection connection = QDBusConnection::sessionBus();
    test object(60);
    //ValueAdaptor是qdbusxml2cpp生成的Adaptor类
    ValueAdaptor valueAdaptor(&object);
    if (!connection.registerService("com.scorpio.test"))
    {
        qDebug() << connection.lastError().message();
        exit(1);
    }
    connection.registerObject("/test/objects", &object);
    return a.exec();
}
```

使用qdbusviewer查看发布的method。

# 自动启动Service

D-Bus系统提供了一种机制可以在访问某个service时，自动把应用程序运行起来。

需要在/usr/share/dbus-1/services下面建立com.scorpio.test.service文件，文件的内容如下：

```bash
[D-BUS Service]
Name=com.scorpio.test
Exec=/path/to/scorpio/test
```

在访问`test`的`method`前，不必手动运行应用程序。



















<style>
body {
    counter-reset: h1
}
h1 {
    counter-reset: h2
}
h2 {
    counter-reset: h3
}
h3 {
    counter-reset: h4
}
h4 {
    counter-reset: h5
}
h5 {
    counter-reset: h6
}
 h1:before {
    counter-increment: h1;
    content: counter(h1) ". "
}
 h2:before {
    counter-increment: h2;
    content: counter(h1) "." counter(h2) ". "
}
 h3:before {
    counter-increment: h3;
    content: counter(h1) "." counter(h2) "." counter(h3) ". "
}
 h4:before {
    counter-increment: h4;
    content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". "
}
 h5:before {
    counter-increment: h5;
    content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". "
}
 h6:before{
    counter-increment: h6;
    content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". "
}
</style>